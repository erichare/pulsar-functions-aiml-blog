<html><body class="c31 doc-content"><p class="c28 title" id="h.dr2jdkuu541t"><span class="c34">Building a Real-Time AI Pipeline with Pulsar Functions: The Basics</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2 c9"><span class="c7"></span></p><h2 class="c11" id="h.ds0e7qcro4aj"><span class="c29">Motivation</span></h2><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">The need for AI and Machine Learning in decision making across a wide array of industries is no secret. But despite the incredible compute power available, and the constant stream of real-time event data, the subclass of &quot;Real-Time AI&quot; is somewhat under-addressed - Particularly is it pertains to live model-retraining and assessment.</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Pulsar functions, which implement serverless compute on top of the well-known open source framework Apache Pulsar, provide a convenient and powerful solution which addresses limitations in the traditional ML workflow. It takes advantage of the inherent Pub-Sub nature of the platform in order to provide a framework for true Real-Time AI. Of course, the scope of Pulsar Functions extends far beyond this domain, but we aim to illustrate how the flexibility of Pulsar Functions is a potential solution for machine learning pipelines that require immediate and real-time predictions and results.</span></p><p class="c2 c9"><span class="c7"></span></p><h2 class="c11" id="h.egg9i0snll2c"><span class="c29">Overview</span></h2><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Our goal is to build a real-time inference engine, powered by Pulsar Functions, that can retrieve low-latency predictions both one at a time, and in bulk. To accomplish this, we have two primary development goals:</span></p><p class="c2 c9"><span class="c7"></span></p><ol class="c23 lst-kix_9lskibkiymne-0 start" start="1"><li class="c2 c22 li-bullet-0"><span class="c7">We must install, configure, and launch Pulsar itself</span></li><li class="c2 c22 li-bullet-0"><span class="c7">We must define the Python functions which will underpin the inference engine</span></li></ol><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">The remainder of this blog walks through those steps, with a particular focus on the Python development side, as well as the calling interface for both registering and triggering Pulsar Functions.</span></p><h3 class="c5" id="h.pttoe3ge7i6h"><span class="c30">Pulsar Standalone</span></h3><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span>With</span><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup><span class="c7">&nbsp;that said, let&#39;s get started by launching a Standalone Pulsar instance. We should note immediately that in a typical deployment of this type of system, Pulsar would be deployed in a Cluster, certainly not a standalone instance on a local machine. But this will allow us to see the power of Real-Time AI prior to a more production-quality deployment.</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Follow the instructions available at: &lt;https://pulsar.apache.org/docs/2.11.x/getting-started-standalone&gt;</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">The Pulsar Standalone instance will be started with the command:</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.0f4498c0359b0e2bbca5fea3f6fb0597457b1c78"></a><a id="t.0"></a><table class="c3"><tr class="c4"><td class="c24" colspan="1" rowspan="1"><p class="c27"><span class="c37">bin/pulsar </span><span class="c18">standalone</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><h2 class="c11 c33" id="h.m4xzoel7i6sh"><span class="c29"></span></h2><h3 class="c5" id="h.tbawerpsmntb"><span class="c30">Iris Flowers Data</span></h3><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">With the instance running, we now turn our attention to defining the Pulsar function that will provide our ML example. We will use the classical Iris Flowers dataset. Collected by Edgar Anderson and popularly used by Ronald Fisher, this dataset contains measurements on 50 flowers, spanning three different flower species. The variables included are as follows:</span></p><p class="c2 c9"><span class="c7"></span></p><ul class="c23 lst-kix_ep8b09vb2761-0 start"><li class="c2 c22 li-bullet-0"><span class="c14">sepallength</span><span class="c7">: The measured length of the flower&#39;s sepal</span></li><li class="c2 c22 li-bullet-0"><span class="c14">sepalwidth</span><span class="c7">: The measured width of the flower&#39;s sepal</span></li><li class="c2 c22 li-bullet-0"><span class="c14">petallength</span><span class="c7">: The measured length of the flower&#39;s petal</span></li><li class="c2 c22 li-bullet-0"><span class="c14">petalwidth</span><span class="c7">: The measured width of the flower&#39;s petal</span></li><li class="c2 c22 li-bullet-0"><span class="c14">class</span><span class="c7">: The species of flower (Setosa, Versicolor, Virginica)</span></li></ul><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">A small preview of this data is given below:</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.956522314f2f6a9a3492486d8dec937218b44573"></a><a id="t.1"></a><table class="c3"><tr class="c4"><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c32 c14">sepallength</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c32 c14">sepalwidth</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c32 c14">petallength</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c14 c32">petalwidth</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c32 c14">class</span></p></td></tr><tr class="c4"><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">5.1</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">3.5</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">1.4</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">0.2</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">Iris-setosa</span></p></td></tr><tr class="c4"><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">4.9</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">3.0</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">1.4</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">0.2</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">Iris-setosa</span></p></td></tr><tr class="c4"><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">4.7</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">3.2</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">1.3</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">0.2</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c10"><span class="c7">Iris-setosa</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span>Our goal will be to accurately predict the </span><span class="c20">class</span><span>&nbsp;given the input features. We will implement the two core components of the model pipeline: training and prediction. The training step will be an offline step (more on this later!) while </span><span class="c14">the prediction step will be the core routine of our Pulsar function</span><span class="c7">. Let&#39;s get started!</span></p><h2 class="c11" id="h.4n74soex84xd"><span class="c29">Pulsar Functions</span></h2><p class="c2"><span class="c7">Now, we are ready to both build and deploy our Pulsar Function.</span></p><h3 class="c5" id="h.o7rio7xrocus"><span class="c30">Building our Pulsar Function</span></h3><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Pulsar functions can be created in a single, standalone Python script, containing the functions which will be deployed. As mentioned, we are going to have the model prediction routine be our primary Pulsar function. A powerful piece of this framework is that the functions themselves are largely standard Python functions, with minimal Pulsar-specific scaffolding. This makes the time to deployment for existing code, or the time to creation for more seasoned Python developers, extremely minimal. Let&#39;s start with a basic framework for pulling Iris data, training a model, and writing it to a Pulsar Topic.</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.a524534d69ba0afeee8a97dd047affbaa31002ac"></a><a id="t.2"></a><table class="c3"><tr class="c4"><td class="c35" colspan="1" rowspan="1"><p class="c27"><span class="c0">import</span><span class="c6">&nbsp;os<br></span><span class="c0">import</span><span class="c6">&nbsp;pickle<br></span><span class="c0">import</span><span class="c6">&nbsp;pandas </span><span class="c0">as</span><span class="c6">&nbsp;pd<br></span><span class="c0">from</span><span class="c6">&nbsp;pulsar </span><span class="c0">import</span><span class="c6">&nbsp;Function<br></span><span class="c0">from</span><span class="c6">&nbsp;sklearn.model_selection </span><span class="c0">import</span><span class="c6">&nbsp;train_test_split<br></span><span class="c0">from</span><span class="c6">&nbsp;sklearn.tree </span><span class="c0">import</span><span class="c6">&nbsp;DecisionTreeClassifier<br><br><br></span><span class="c0">def</span><span class="c13">&nbsp;</span><span class="c14 c19">train_iris_model</span><span class="c13">():</span><span class="c6"><br> &nbsp; &nbsp;</span><span class="c15"># If we already have an existing model file, we can load it right away</span><span class="c6"><br> &nbsp; &nbsp;</span><span class="c0">if</span><span class="c6">&nbsp;os.path.exists(</span><span class="c8">&quot;model.pkl&quot;</span><span class="c6">):</span><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup></p><p class="c27"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp; print(</span><span class="c8">&quot;We are loading a pre-existing model&quot;</span><span class="c6">)<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">return</span><span class="c6">&nbsp;pickle.load(open(</span><span class="c8">&quot;model.pkl&quot;</span><span class="c6">, </span><span class="c8">&#39;rb&#39;</span><span class="c6">))<br><br> &nbsp; &nbsp;</span><span class="c15"># Read in the iris data, split into a 20% test component</span><span class="c6"><br> &nbsp; &nbsp;iris = pd.read_csv(</span><span class="c8">&quot;https://datahub.io/machine-learning/iris/r/iris.csv&quot;</span><span class="c6">)<br> &nbsp; &nbsp;train, test = train_test_split(iris, test_size=</span><span class="c15 c16">0.2</span><span class="c6">, stratify=iris[</span><span class="c8">&#39;class&#39;</span><span class="c6">])<br><br> &nbsp; &nbsp;</span><span class="c15"># Get the training data</span><span class="c6"><br> &nbsp; &nbsp;X_train = train[[</span><span class="c8">&#39;sepalwidth&#39;</span><span class="c6">, </span><span class="c8">&#39;sepallength&#39;</span><span class="c6">, </span><span class="c8">&#39;petalwidth&#39;</span><span class="c6">, </span><span class="c8">&#39;petallength&#39;</span><span class="c6">]]<br> &nbsp; &nbsp;y_train = train[</span><span class="c8">&#39;class&#39;</span><span class="c6">]<br><br> &nbsp; &nbsp;</span><span class="c15"># Get the test data</span><span class="c6"><br> &nbsp; &nbsp;X_test = test[[</span><span class="c8">&#39;sepalwidth&#39;</span><span class="c6">, </span><span class="c8">&#39;sepallength&#39;</span><span class="c6">, </span><span class="c8">&#39;petalwidth&#39;</span><span class="c6">, </span><span class="c8">&#39;petallength&#39;</span><span class="c6">]]<br> &nbsp; &nbsp;y_test = test[</span><span class="c8">&#39;class&#39;</span><span class="c6">]<br><br> &nbsp; &nbsp;</span><span class="c15"># Train the model </span><span class="c6"><br> &nbsp; &nbsp;model = DecisionTreeClassifier(max_depth=</span><span class="c15 c16">3</span><span class="c6">, random_state=</span><span class="c15 c16">1</span><span class="c6">)<br> &nbsp; &nbsp;model.fit(X_train, y_train)<br><br> &nbsp; &nbsp;</span><span class="c15"># Dump the model object to a file</span><span class="c6"><br> &nbsp; &nbsp;pickle.dump(model, open(</span><span class="c8">&quot;model.pkl&quot;</span><span class="c6">, </span><span class="c8">&#39;wb&#39;</span><span class="c6">))<br><br> &nbsp; &nbsp;</span><span class="c0">return</span><span class="c6">&nbsp;model</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">In this code block, we train a Decision Tree Classifier in an attempt to predict the flower species based on the width and length of the sepals and petals. A Decision Tree Classifier can be intuitively represented as a series of decisions based on feature values, culminating in a prediction when a leaf node of the tree is reached. An example tree derived from this model is given below:</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 500.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 500.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span>One thing to note - we use the </span><span class="c20">pickle</span><span>&nbsp;module to serialize the model upon training. This will dump the model to a file in the working </span><span>directory</span><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup><span class="c7">. Subsequent calls to the function will, if the pickled model is available, simply read the model in rather than go through the (sometimes expensive) retraining steps. This will be a key point as we continue fleshing out the example, since it allows for a separate routine that is responsible for continual assessment, augmentation, and re-training of the model as new data is collected.</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span>Thus far, we have written the code that will train the Decision Tree Classification Model. It&#39;s time to build the routine which will represent our Pulsar Function. We will create a sub-class </span><span class="c20">IrisPredictionFunction</span><span>&nbsp;of the Function class in Pulsar, implementing two methods: an </span><span class="c20">__init__() </span><span>method which does nothing, and a </span><span class="c20">__process__() </span><span class="c7">method which, given an input and a user context, returns a prediction from the model.</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.6e4112d02c945a440581c98690af9f3840f14415"></a><a id="t.3"></a><table class="c3"><tr class="c4"><td class="c35" colspan="1" rowspan="1"><p class="c27"><span class="c0">class</span><span class="c6">&nbsp;</span><span class="c19 c14">IrisPredictionFunction</span><span class="c6">(</span><span class="c19 c14">Function</span><span class="c6">):<br> &nbsp; &nbsp;</span><span class="c15"># No initialization code needed</span><span class="c6"><br> &nbsp; &nbsp;</span><span class="c0">def</span><span class="c13">&nbsp;</span><span class="c19 c14">__init__</span><span class="c13">(</span><span class="c0">self</span><span class="c13">)</span><span class="c6">:<br> &nbsp; &nbsp; &nbsp; &nbsp;pass<br><br> &nbsp; &nbsp;</span><span class="c0">def</span><span class="c13">&nbsp;</span><span class="c19 c14">process</span><span class="c13">(</span><span class="c0">self</span><span class="c13">, input, context)</span><span class="c6">:<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15"># Convert the input ratio to a float, if it isn&#39;t already</span><span class="c6"><br> &nbsp; &nbsp; &nbsp; &nbsp;flower_parameters = [float(x) </span><span class="c0">for</span><span class="c6">&nbsp;x </span><span class="c0">in</span><span class="c6">&nbsp;input.split(</span><span class="c8">&quot;,&quot;</span><span class="c6">)]<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15"># Get the prediction</span><span class="c6"><br> &nbsp; &nbsp; &nbsp; &nbsp;model = train_iris_model()<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">return</span><span class="c6">&nbsp;model.predict([flower_parameters])[</span><span class="c15 c16">0</span><span class="c6">]</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span>This function does not depend on the user context - parameters and configuration options specific to the calling user could be used to tweak the behavior, if desired. But for this function, we simply rely on the input. Since the model was trained on the four flower features </span><span class="c20">sepallength</span><span>, </span><span class="c20">sepalwidth</span><span>, </span><span class="c20">petallength</span><span>, and </span><span class="c20">petalwidth</span><span class="c7">, we must provide each, and in the order that the model was trained. For ease and simplicity, we assume that these are passed as a comma separated string. For example, the consider the following string:</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c20 c21">1.8,2.1,4.0,1.4</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">This represents a flower with the following measurements:</span></p><p class="c2 c9"><span class="c7"></span></p><ul class="c23 lst-kix_lww5lmxnm8sf-0 start"><li class="c2 c22 li-bullet-0"><span class="c14">sepallength</span><span class="c7">: 1.8</span></li><li class="c2 c22 li-bullet-0"><span class="c14">sepalwidth</span><span class="c7">: 2.1</span></li><li class="c2 c22 li-bullet-0"><span class="c14">petallength</span><span class="c7">: 4.0</span></li><li class="c2 c22 li-bullet-0"><span class="c14">petalwidth</span><span class="c7">: 1.4</span></li></ul><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Our pulsar function will take this string, split on the comma, convert the values to floats, and then pass it to the model prediction routine.</span></p><p class="c2 c9"><span class="c7"></span></p><h3 class="c5" id="h.ma7ycx5g0to5"><span class="c30">Deploying our Pulsar Function</span></h3><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Now for the easy part - deployment! With the `pulsar standalone` client running, we need only to create and trigger our function. We first create it, like so:</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.265001e97195d1c7c26de892bb9a3eabbdc66c53"></a><a id="t.4"></a><table class="c3"><tr class="c4"><td class="c24" colspan="1" rowspan="1"><p class="c27"><span class="c18">bin/pulsar-admin functions create \ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp;--tenant public \<br> &nbsp;--namespace default \<br> &nbsp;--name iris_prediction_1 \<br> &nbsp;--py iris_prediction.py \ &nbsp; &nbsp; &nbsp;<br> &nbsp;--timeout-ms </span><span class="c26">10000</span><span class="c18">&nbsp;\<br> &nbsp;--classname iris_prediction.IrisPredictionFunction \<br> &nbsp;--inputs </span><span class="c26">persistent:</span><span class="c18">/</span><span class="c12">/public/default/in \<br></span><span class="c18">&nbsp; -</span><span class="c12">-output persistent://public/default/out</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Note a few parameters:</span></p><p class="c2 c9"><span class="c7"></span></p><ul class="c23 lst-kix_gmo547uclqx5-0 start"><li class="c2 c22 li-bullet-0"><span class="c14">--name</span><span class="c7">&nbsp;provides us with the name to reference the function to trigger it in the future. This can be whatever is most convenient, but should be unique.</span></li><li class="c2 c22 li-bullet-0"><span class="c14">--py</span><span>&nbsp;is the name of the python script which contains the code we have written. Here, I&#39;ve saved our code as a script </span><span class="c20">iris_prediction.py</span><span class="c7">&nbsp;which is included with this blog.</span></li><li class="c2 c22 li-bullet-0"><span class="c14">--classname</span><span class="c7">&nbsp;is the name of the class within the python script, fully qualified, as shown above.</span></li></ul><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Finally, we can trigger our function! Let&#39;s pass in the parameters we used as an example above:</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.3c6dc2c29e0dcfab6c557acbc9c7977230b43517"></a><a id="t.5"></a><table class="c3"><tr class="c4"><td class="c24" colspan="1" rowspan="1"><p class="c27"><span class="c18">bin/pulsar-admin functions trigger \<br> &nbsp;--tenant public \<br> &nbsp;--namespace</span><span class="c25">&nbsp;default </span><span class="c18">\<br> &nbsp;--name iris_prediction_1 \<br> &nbsp;--trigger-value 1.8,2.1,4.0,1.4</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><h2 class="c11" id="h.9rstjawedt9g"><span class="c29">Bonus: Bulk Prediction</span></h2><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">This function works great for the predicted species of a single Iris flower. But in the real world, we may wish to obtain predictions for a large number of observations at once. Fortunately, this is a trivial modification to the above function, and can be included along-side the single flower prediction function. Let&#39;s add the following class, which we will use to create a new Pulsar Function:</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.dcb045c76c52d2c37adaf4b10c3c37836aaad670"></a><a id="t.6"></a><table class="c3"><tr class="c4"><td class="c35" colspan="1" rowspan="1"><p class="c27"><span class="c0">class</span><span class="c6">&nbsp;</span><span class="c19 c14">IrisPredictionFunctionBulk</span><span class="c6">(</span><span class="c19 c14">Function</span><span class="c6">):<br> &nbsp; &nbsp;</span><span class="c15"># No initialization code needed</span><span class="c6"><br> &nbsp; &nbsp;</span><span class="c0">def</span><span class="c13">&nbsp;</span><span class="c19 c14">__init__</span><span class="c13">(</span><span class="c0">self</span><span class="c13">)</span><span class="c6">:<br> &nbsp; &nbsp; &nbsp; &nbsp;pass<br><br> &nbsp; &nbsp;</span><span class="c0">def</span><span class="c13">&nbsp;</span><span class="c19 c14">process</span><span class="c13">(</span><span class="c0">self</span><span class="c13">, input, context)</span><span class="c6">:<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15"># Convert the input parameters to floats, if they aren&#39;t already</span><span class="c6"><br> &nbsp; &nbsp; &nbsp; &nbsp;flower_parameters_str = input.split(</span><span class="c8">&quot;:&quot;</span><span class="c6">)<br> &nbsp; &nbsp; &nbsp; &nbsp;flower_parameters_split = [x.split(</span><span class="c8">&quot;,&quot;</span><span class="c6">) </span><span class="c0">for</span><span class="c6">&nbsp;x </span><span class="c0">in</span><span class="c6">&nbsp;flower_parameters_str]<br> &nbsp; &nbsp; &nbsp; &nbsp;flower_parameters_float = [[float(x) </span><span class="c0">for</span><span class="c6">&nbsp;x </span><span class="c0">in</span><span class="c6">&nbsp;y] </span><span class="c0">for</span><span class="c6">&nbsp;y </span><span class="c0">in</span><span class="c6">&nbsp;flower_parameters_split]<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15"># Get the prediction</span><span class="c6"><br> &nbsp; &nbsp; &nbsp; &nbsp;model = train_iris_model()<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">return</span><span class="c6">&nbsp;</span><span class="c8">&quot;, &quot;</span><span class="c6">.join(model.predict(flower_parameters_float))</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">This function is similar, but:</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">1. Defines a new class name to allow us to distinguish it when registering the function</span></p><p class="c2"><span class="c7">2. Assumes that we may have more than one set of flower measurements, split by a `:` character</span></p><p class="c2"><span class="c7">3. Joins the resulting model predictions into a comma-separated string of predictions, rather than an array</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">Much like before, we register the function, making sure to define a new name and refer to the correct class name that we just created:</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.10593ea4baf2249b36773cd14d3436dc4accd627"></a><a id="t.7"></a><table class="c3"><tr class="c4"><td class="c24" colspan="1" rowspan="1"><p class="c27"><span class="c18">bin/pulsar-admin functions create \<br> &nbsp;--tenant public \<br> &nbsp;--namespace default \<br> &nbsp;--name iris_prediction_bulk_1 \<br> &nbsp;--py iris_prediction.py \<br> &nbsp;--timeout-ms </span><span class="c26">10000</span><span class="c18">&nbsp;\<br> &nbsp;--classname iris_prediction.IrisPredictionFunctionBulk \<br> &nbsp;--inputs </span><span class="c26">persistent:</span><span class="c18">/</span><span class="c12">/public/default/in \<br></span><span class="c18">&nbsp; -</span><span class="c12">-output persistent://public/default/out</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">And finally, we trigger the function - let&#39;s pass in three sets of flower measurements at once, like so:</span></p><p class="c2 c9"><span class="c7"></span></p><a id="t.1a9883bb51a2edf91641ddb2ea733714443bd2f2"></a><a id="t.8"></a><table class="c3"><tr class="c4"><td class="c24" colspan="1" rowspan="1"><p class="c27"><span class="c18">bin/pulsar-admin functions trigger \<br> &nbsp;--tenant public \<br> &nbsp;--namespace</span><span class="c25">&nbsp;default </span><span class="c18">\<br> &nbsp;--name iris_prediction_bulk_1 \<br> &nbsp;--trigger-value 1.8,2.1,4.0,1.4:0.1,0.1,0.1,0.1:1.8,2.5,0.5,5.0</span></p></td></tr></table><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">And there we have it! Real-time predictions of Iris flower species based on the measurements, using Pulsar Functions in Python.</span></p><p class="c2 c9"><span class="c7"></span></p><h2 class="c11" id="h.z11xgbfei6dz"><span class="c29">Conclusion</span></h2><p class="c2 c9"><span class="c7"></span></p><p class="c2"><span class="c7">While this example merely scratches the surface of what&#39;s possible with Pulsar Functions, I believe it provides a blueprint for implementing a Real-Time AI pipeline using Apache Pulsar. With Pulsar&#39;s power underlying the core framework, complex Pub-Sub systems with large amounts of real-time data can be seamlessly processed, with the resulting output from the inference model consumed directly, or even used in a downstream task.</span></p><p class="c2 c9"><span class="c7"></span></p><p class="c2 c9"><span class="c7"></span></p><div><p class="c2 c9"><span class="c7"></span></p></div></body></html>
